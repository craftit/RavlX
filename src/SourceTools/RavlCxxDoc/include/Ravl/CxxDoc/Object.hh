// This file is part of CxxDoc, The RAVL C++ Documentation tool 
// Copyright (C) 2001, University of Surrey
// This code may be redistributed under the terms of the GNU General 
// Public License (GPL). See the gpl.licence file for details or
// see http://www.gnu.org/copyleft/gpl.html
// file-header-ends-here
#ifndef RAVLCXXDOC_OBJECT_HEADER
#define RAVLCXXDOC_OBJECT_HEADER 1
//////////////////////////////////////////////////////////
//! rcsid="$Id$"
//! file="Ravl/SourceTools/CxxDoc/Object.hh"
//! userlevel=Normal
//! docentry="Ravl.API.Source Tools.CxxDoc.Internal"
//! lib=RavlCxxDoc
//! author="Charles Galambos"
//! date="08/12/1999"

#include "Ravl/String.hh"
#include "Ravl/RefCounter.hh"
#include "Ravl/DList.hh"
#include "Ravl/Hash.hh"
#include "Ravl/HSet.hh"
#include "Ravl/RCHash.hh"
#include "Ravl/Tuple2.hh"

//: C++ parser's namespace.
// This namespace contains the classes that make up the parser, the parse tree 
// and the C++ documenation system.

namespace RavlCxxDocN {
  
  using namespace RavlN;
  
  class ObjectC;
  class ObjectBodyC;
  class ObjectListC;
  class ScopeBodyC;
  class DerivedC;
  class ClassTemplateC;
  class ObjectTemplateC;  
  class MethodTemplateC;
  class MarkerC;
  
  enum ScopeAccessT { SAPrivate, SAPublic, SAProtected }; 
  
  //! userlevel=Advanced
  //: Description generator.
  // This class is used to control the text generated by
  // various functions in C++ class tree.
  
  class DesciptionGeneratorC {
  public:
    DesciptionGeneratorC()
    {}
    //: Default constructor.
    
    virtual ~DesciptionGeneratorC()
    {}
    //: Destructor.
    
    virtual StringC TextFor(char let);
    //: Render a character.
    // Typical used for '<' '>' and the like..
    
    virtual StringC TextFor(const ObjectC &obj);
    //: Render a an object description.
    
    virtual StringC TextFor(const StringC &obj);
    //: Render a string 'as is'.

    virtual StringC MethodNameText(const StringC &obj);
    //: Render a method name appropriatly. (e.g. bold.)
    
  };
  
  extern DesciptionGeneratorC defaultDescGen; // Default do nothing description generator.
  extern RCHashC<StringC,ObjectC> emptyTemplSubst; // Empty template subsitution.
  
  StringC PathName(DListC<ObjectC> path,DesciptionGeneratorC &dg = defaultDescGen,int maxDepth = 60);
  //: Generate a full path name.

  StringC PathName(DListC<ObjectC> path,
		   HashC<StringC,StringC> &templSub,
		   DesciptionGeneratorC &dg = defaultDescGen,
		   int maxDepth = 30);
  //: Generate a full path name, with template paramiter subs.

  
  //! userlevel=Normal
  //: Class containing comment info.
  
  class CommentInfoC {
  public:
    CommentInfoC()
      : startLine(-1),
	endLine(-1)
    {}
    //: Default constructor.
    
    StringC &Text()
    { return text; }
    //: Access text of comment.
    // Access the text or detailed comment.
    
    StringC &Header()
    { return header; }
    //: Access header of comment.
    // Access the header or brief comment.

    const StringC &Text() const
    { return text; }
    //: Access text of comment.
    // Access the text or detailed comment.
    
    const StringC &Header() const
    { return header; }
    //: Access header of comment.
    // Access the header or brief comment.
    
    StringC &Var(const StringC &nm)
    { return vars[nm]; }
    //: Access a global variable.
    // Creates a new entry in the table if not
    // found.
    
    StringC Var(const StringC &nm) const { 
      if(!vars.IsElm(nm))
	return StringC();
      return vars[nm]; 
    }
    //: Access a global variable
    // Returns an empty string if its not found.
    
    void SetVar(const StringC &nm,const StringC &value);
    //: Set a global variable.
    
    HashC<StringC,StringC> &Vars()
    { return vars; }
    //: Access global variable table.
    
    const HashC<StringC,StringC> &Vars() const
    { return vars; }
    //: Access global variable table.

    RCHashC<StringC,StringC> &Locals()
    { return locals; }
    //: Access local variable table.

    const RCHashC<StringC,StringC> &Locals() const
    { return locals; }
    //: Access local variable table.
    
    void Reset() {
      text = StringC();
      header = StringC();
      locals = RCHashC<StringC,StringC>();
      startLine=-1;
      endLine=-1;
    }
    //: Reset comment.
    // Used to reset comments between language elements in a file.
    
    void FileReset() {
      Reset();
      vars.Empty();
    }
    //: Reset comment and local variables.
    // Used to reset comments on the start of processing a new file.
    // This removes all gobal variables as well as local ones.
    
    void SetEndLine(IntT el)
    { endLine = el; }
    //: Set end line.
    
    void SetStartLine(IntT sl)
    { startLine = sl; }
    //: Set end line.
    
    IntT EndLine()
    { return endLine; }
    //: Set end line.
    
    IntT StartLine()
    { return startLine; }
    //: Set end line.
    
  protected:
    StringC text;
    StringC header;
    HashC<StringC,StringC> vars;
    RCHashC<StringC,StringC> locals;
    IntT startLine;
    IntT endLine;
  };
  
  //! userlevel=Develop
  //: Object body.
  // The base body class for all parsed output.
  
  class ObjectBodyC 
    : public RCBodyVC
  {
  public:
    ObjectBodyC();
    //: Constructor.
    
    ObjectBodyC(const StringC &nname);
    //: Constructor.
    
    StringC &Name()
    { return name; }
    //: Name of object.

    const StringC &Name() const
    { return name; }
    //: Name of object.
    
    virtual const char *TypeName() const 
    { return "object"; }
    //: Get name of object type.
    
    void SetName(const StringC &nname)
    { name = nname; }
    //: Set name of object.

    void SetComment(const CommentInfoC &cinf);
    //: Set comment information.
    
    CommentInfoC &Comment()
    { return comment; }
    //: Access comment.

    const CommentInfoC &Comment() const
    { return comment; }
    //: Access comment.
    
    void SetVar(const StringC &nm,const StringC &value)
    { comment.SetVar(nm,value); }
    //: Set variable.
    
    StringC Var(const StringC &nm) const
    { return comment.Var(nm); }
    //: Get variable.
    
    bool IsVar(const StringC &nm) const
    { return comment.Vars().IsElm(nm); }
    //: Test if variable is set.
    
    virtual void Dump(std::ostream &out,int indent = 0);
    //: Dump to 'out' in human readable form.
    
    virtual void SetScope(ObjectC &obj) {}
    //: Set scope for this object.
    
    virtual ObjectC GetScope();
    //: Get scope for this object.
    
    void UpdateComment(CommentInfoC &newComment);
    //: Update the comments for the object.
    
    bool HasParentScope() const
    { return parent != 0; }
    //: Has a parent been set ?
    
    ScopeBodyC &ParentScope()
    { return *parent; }
    //: Access parent.
    // ONLY valid if HasParent() returns true.
    
    const ScopeBodyC &ParentScope() const
    { return *parent; }
    //: Access parent.
    // ONLY valid if HasParent() returns true.
    
    void SetParentScope(ScopeBodyC *ns);
    //: Setup parent scope.
    
    ObjectListC PathList() const;
    // : Generate path list to this object.
    
    StringC FullPath() const;
    //: Get full path to object.
    
    virtual StringC ActualPath() const
    { return FullPath(); }
    //: Resolve data references correctly.

    int &StartLineno()
    { return startLineno; }
    //: Starting line of object.
    
    int &EndLineno()
    { return endLineno; }
    //: End line of object.
    
    void CopyLineNo(const ObjectBodyC &ob) {
      startLineno = ob.startLineno;
      endLineno = ob.endLineno;
    }
    //: Copy line no from object.
    
    void IncludeLineNo(const ObjectBodyC &ob) {
      if(ob.startLineno >= 0) {
	if(startLineno < 0 || ob.startLineno < startLineno)
	  startLineno = ob.startLineno;
      }
      if(ob.endLineno > endLineno)
	endLineno = ob.endLineno;
    }
    //: Include lines into object.

    void CopyLineNo(const ObjectC &ob);
    //: Copy line no from object.
    
    void IncludeLineNo(const ObjectC &ob);
    //: Include lines into object.

    virtual ObjectListC &TemplArgList();
    //: Access arg list.
    
    virtual bool IsTemplate() const
    { return false; }
    //: Is this a templated object ?

    virtual const StringC &BaseName() const
    { return Name(); }
    //: Return base name.
    
    UIntT Hash() const
    { return name.Hash(); }
    //: Hash name.
    
    inline bool operator==(const ObjectC &ob) const;
    //: Is equal ?

    virtual StringC FullName(RCHashC<StringC,ObjectC> &templSub,DesciptionGeneratorC &dg = defaultDescGen,int maxDepth = 60) const;
    //: Get full name of object
    // template args and all.

    virtual ObjectC Subst(RCHashC<StringC,ObjectC> &subst) const;
    //: Create a new object with subsituted args.
    
  protected:
    std::ostream & Pad(std::ostream &out,int indent);
    //: Put padding spaces in.
    
    StringC name;
    CommentInfoC comment;    
    ScopeBodyC *parent;
    int startLineno,endLineno;
  };

  //! userlevel=Normal
  //: Ya basic object.
  
  class ObjectC 
    : public RCHandleC<ObjectBodyC>
  {
  public:
    ObjectC()
    {}
    //: Default Constructor.
    
    explicit ObjectC(bool)
      : RCHandleC<ObjectBodyC>(*new ObjectBodyC())
    {}
    //: Constructor.
    
    ObjectC(const char *nname)
      : RCHandleC<ObjectBodyC>(*new ObjectBodyC(StringC(nname)))
    {}
    //: Construct named object.
    
    ObjectC(const StringC &nname)
      : RCHandleC<ObjectBodyC>(*new ObjectBodyC(nname))
    {}
    //: Constructor.

    ObjectC(const ObjectC &org)
      : RCHandleC<ObjectBodyC>(org)
    {}
    //: Copy constructor.
    // Creates a new handle only.
    
  protected:
    ObjectC(ObjectBodyC &bod)
      : RCHandleC<ObjectBodyC>(bod)
    {}
    //: Body constructor.
    
    ObjectC(const ObjectBodyC *bod)
      : RCHandleC<ObjectBodyC>(bod)
    {}
    //: Body constructor.
    
    ObjectBodyC &Body() 
    { return RCHandleC<ObjectBodyC>::Body(); }
    //: Access body.
    
    const ObjectBodyC &Body() const
    { return RCHandleC<ObjectBodyC>::Body(); }
    //: Access body.
  public:
    
    StringC &Name()
    { return Body().Name(); }
    //: Name of object.

    const StringC &Name() const
    { return Body().Name(); }
    //: Name of object.

    void SetName(const StringC &nname)
    { Body().SetName(nname); }
    //: Name of object.

    const char *TypeName() const 
    { return Body().TypeName(); }
    //: Get name of object type.

    void SetComment(const CommentInfoC &cinf)
    { Body().SetComment(cinf); }
    //: Set comment info.
    
    CommentInfoC &Comment()
    { return Body().Comment(); }
    //: Access comment.
    
    const CommentInfoC &Comment() const
    { return Body().Comment(); }
    //: Access comment.

    void SetVar(const StringC &nm,const StringC &value)
    { Body().SetVar(nm,value); }
    //: Set variable.

    StringC Var(const StringC &nm)
    { return Body().Var(nm); }
    //: Set variable.
    
    StringC Var(const StringC &nm) const
    { return Body().Var(nm); }
    //: Set variable.

    bool IsVar(const StringC &nm) const
    { return Body().IsVar(nm); }
    //: Set variable.
    
    void Dump(std::ostream &out,int indent = 0)
    { Body().Dump(out,indent); }
    //: Dump to 'out' in human readable form.
    
    void SetScope(ObjectC &obj)
    { Body().SetScope(obj); }
    //: Set scope for object.
    
    void UpdateComment(CommentInfoC &newComment)
    { Body().UpdateComment(newComment); }
    //: Update the comments for the object.
    
    ObjectC GetScope() 
    { return Body().GetScope(); }
    //: Set scope for object.
    
    void SetParentScope(ScopeBodyC *ns)
    { Body().SetParentScope(ns); }
    //: Setup parent scope.
    
    bool HasParentScope() const
    { return Body().HasParentScope(); }
    //: Has a parent been set ?
    
    ScopeBodyC &ParentScope()
    { return Body().ParentScope(); }
    //: Access parent.
    // ONLY valid if HasParent() returns true.
    
    StringC FullPath() const
    { return Body().FullPath(); }
    //: Get full path to object.
    
    StringC ActualPath() const
    { return Body().ActualPath(); }
    //: Resolve data references correctly.
    
    ObjectListC PathList() const;
    // : Generate path list to this object.
    
    int &StartLineno()
    { return Body().StartLineno(); }
    //: where does object start.
    
    int &EndLineno()
    { return Body().EndLineno(); }
    //: where does object end.

    void CopyLineNo(const ObjectC &ob)
    { Body().CopyLineNo(ob.Body()); }
    //: Copy line no from object.
    
    void IncludeLineNo(const ObjectC &ob)
    { Body().IncludeLineNo(ob.Body()); }
    //: Include lines into object.

    void SetupLineNos(const ObjectC &ob1,const ObjectC &ob2) {  
      Body().CopyLineNo(ob1.Body()); 
      Body().IncludeLineNo(ob2.Body()); 
    }
    //: Include lines into object.
    
    void SetupLineNos(const ObjectC &ob1,const ObjectC &ob2,const ObjectC &ob3) {  
      Body().CopyLineNo(ob1.Body()); 
      Body().IncludeLineNo(ob2.Body()); 
      Body().IncludeLineNo(ob3.Body()); 
    }
    //: Include lines into object.

    bool IsTemplate() const
    { return Body().IsTemplate(); }
    //: Is this a templated object ?

    ObjectListC &TemplArgList()
    { return Body().TemplArgList(); }
    //: Access arg list.
    
    UIntT Hash() const
    { return Body().Hash(); }
    //: Hash number for object.
    
    bool operator==(const ObjectC &ob) const
    { return Body().operator==(ob); }
    //: Is equal ?
    
    const StringC &BaseName() const
    { return Body().BaseName(); }
    //: Return base name.
    
    StringC FullName(RCHashC<StringC,ObjectC> &templSub = emptyTemplSubst,DesciptionGeneratorC &dg = defaultDescGen,int maxDepth = 40) const
    { return Body().FullName(templSub,dg,maxDepth); }
    //: Get full name of object
    // template args and all.

    ObjectC Subst(RCHashC<StringC,ObjectC> &subst) const
    { return Body().Subst(subst); }
    //: Create a new object with subsituted args.
    
    friend class ObjectListC;
    friend class ObjectTemplateC;
    friend class ObjectTemplateBodyC;
    friend class ObjectBodyC;
    friend class ScopeC;
    friend class ClassC;
    friend class ClassTemplateC;
    friend class ClassTemplateBodyC;
    friend class MethodC;
    friend class TypedefC;
    friend class VariableC;
    friend class InheritC;
    friend class ScopeBodyC;
    friend class DataTypeC;
    friend class DataTypeBodyC;
    friend class DerivedC;
    friend class EnumC;
    friend class MethodTemplateC;  
    friend class MarkerC;  
  };

  inline
  bool ObjectBodyC::operator==(const ObjectC &ob) const
  { return name == ob.Name(); }
  //: Is equal ?
  
  std::ostream &operator<<(std::ostream &,const ObjectC &out);
  //: Output to stream.
  
  std::istream &operator>>(std::istream &,ObjectC &out);
  //: Input from stream.
  // Not implemented.
  
  BinOStreamC &operator<<(BinOStreamC &,const ObjectC &out);
  //: Output to stream.
  // Not implemented.
  
  BinIStreamC &operator>>(BinIStreamC &,ObjectC &out);
  //: Input from stream.
  // Not implemented.
  
  
  /////////////////////////////////////////////////
  //! userlevel=Develop
  //: Object list
    
  class ObjectListBodyC 
    : public ObjectBodyC
  {
  public:
    ObjectListBodyC(bool awrap = false)
      : wrapper(awrap)
    {}
    //: Default constructor.
    
    ObjectListBodyC(const StringC &nname)
      : ObjectBodyC(nname),
	wrapper(false)
    {}
    //: Constructor.
    
    ObjectListBodyC(const StringC &nname,DListC<ObjectC> &contents)
      : ObjectBodyC(nname),
	list(contents),
	wrapper(false)
    {}
    //: Constructor.

    virtual const char *TypeName() const 
    { return "objlist"; }
    //: Get name of object type.
    
    DListC<ObjectC> &List()
    { return list; }
    //: Access list.

    const DListC<ObjectC> &List() const
    { return list; }
    //: Access list.
    
    ObjectC Find(const StringC &name);
    //: Find named child.
    // returns an invalid handle if not found.
    
    virtual void Append(ObjectC &obj);
    //: Append to list.
    
    bool IsWrapper() const { return wrapper; }
    //: Is a wrapper ?
    // Is this used to return multipal items ??
    
    virtual void Dump(std::ostream &out,int indent = 0);
    //: Dump to 'out' in human readable form.

    void AppendList(DListC<ObjectC> &contents);
    //: Append list to list one.

    void AppendList(const ObjectC &contents);
    //: Append list to list one.
    
    void SetAll(const StringC &var,const StringC &dat);
    //: Set variable in all immediate children.

    void SetWrapper(bool val = true)
    { wrapper = val; }
    //: Set the wrapper flag.
    
  protected:
    DListC<ObjectC> list;
    bool wrapper;
  };
  
  //! userlevel=Normal
  //: Object list
  
  class ObjectListC 
    : public ObjectC 
  {
  public:
    ObjectListC()
    {}
    //: Default constructor
    
    ObjectListC(const StringC &x,bool awrap)
      : ObjectC(*new ObjectListBodyC(awrap))
    {}
    //: Default Constructor.
    // creates an invalid object.
    
    ObjectListC(const StringC &nname)
      : ObjectC(*new ObjectListBodyC(nname))
    {}
    //: Constructor.
    
    ObjectListC(const char *name)
      : ObjectC(*new ObjectListBodyC(StringC(name)))
    {}
    //: Construct named list.
    
    ObjectListC(const StringC &nname,DListC<ObjectC> &contents)
      : ObjectC(*new ObjectListBodyC(nname,contents))
    {}
    //: Constructor.
    
    static bool IsA(const ObjectC &obj)
    { return dynamic_cast<const ObjectListBodyC *>(&obj.Body()) != 0; }
    
    ObjectListC(const ObjectC &obj)
      : ObjectC(dynamic_cast<const ObjectListBodyC *>(BodyPtr(obj)))
    {}
    //: Base class constructor.
    
  protected:
    ObjectListC(ObjectListBodyC &bod)
      : ObjectC(bod)
    {}
    //: Body constructor.
    
    ObjectListC(const ObjectListBodyC *bod)
      : ObjectC(bod)
    {}
    //: Body constructor.
    
    ObjectListBodyC &Body() 
    { return dynamic_cast<ObjectListBodyC &>(ObjectC::Body()); }
    //: Access body.

    const ObjectListBodyC &Body() const
    { return dynamic_cast<const ObjectListBodyC &>(ObjectC::Body()); }
    //: Access body.
    
  public:
    DListC<ObjectC> &List() { 
      RavlAssert(IsValid());
      return Body().List(); 
    }
    //: Access list.
    
    const DListC<ObjectC> &List() const
    { return Body().List(); }
    //: Access list.
    
    void Append(const ObjectC &obj) { 
      RavlAssert(IsValid());
      Body().Append(const_cast<ObjectC &>(obj)); 
    }
    //: Append to list.
    
    void SetWrapper(bool val = true) 
    { Body().SetWrapper(val); }
    //: Set wrapper flag.
    
    bool IsWrapper() const 
    { return Body().IsWrapper(); }
    //: Is a wrapper ?
    // Is this used to return multipal items ??
    
    void SetAll(const StringC &var,const StringC &dat)
    { Body().SetAll(var,dat); }
    //: Set variable in all immediate children.
    
    ObjectC Find(const StringC &name)
    { return Body().Find(name); }
    //: Find named child.
    // returns an invalid handle if not found.
    
  };


}



#endif
