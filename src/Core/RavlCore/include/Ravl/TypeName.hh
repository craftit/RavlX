// This file is part of RAVL, Recognition And Vision Library 
// Copyright (C) 2001, University of Surrey
// This code may be redistributed under the terms of the GNU Lesser
// General Public License (LGPL). See the lgpl.licence file for details or
// see http://www.gnu.org/copyleft/lesser.html
// file-header-ends-here
#ifndef RAVL_TYPENAME_HEADER
#define RAVL_TYPENAME_HEADER 1
///////////////////////////////////////////////
//! docentry="Ravl.API.Core.IO.Type Name"
//! rcsid="$Id$"
//! file="Ravl/Core/System/TypeName.hh"
//! lib=RavlCore
//! author="Charles Galambos"
//! date="23/10/1998"
//! userlevel=Normal

#include "Ravl/config.h"

#if RAVL_HAVE_ANSICPPHEADERS
#include <typeinfo>
#else
#include <typeinfo.h>
#endif

namespace RavlN {
#if RAVL_HAVE_STDNAMESPACE
  using namespace std;
#endif
  
  // Unfortunately the C++ standard does not specify what
  // string is returned from the std::type_info.name() function.
  // This means if you wish to use files containing with
  // code generated by different compilers you'll get 
  // inconsistent results.
  // These functions are here to help get around the problem.
  
  const char *TypeName(const std::type_info &info);
  //: Return the C++ type name for a type info instance.
  // This function will return a standard name
  // for a class if one is known. The function will attempt
  // to generate a standard name if one is not defined. 
  // If this cannot be done a warning is printed on standard
  // error channel and the program will continue with the
  // compiler generated name.
  
  bool HaveTypeName(const std::type_info &info);
  //: Test if we have a typename registered

  const char *TypeHandleName(const std::type_info &info);
  //: Lookup the name of a handle type from body std::type_info structure.
  
  const char *TypeName(const char *name);  
  //: Return the C++ name for a std::type_info.name().
  // Same as TypeName(const std::type_info &)  but uses the std::type_info.name() directly.
  
  const char *RTypeName(const char *name);
  //: Given a standardised name return the compiler specific one.
  // Reverse lookup.  Given the standard name find the
  // compiler specific one. 
  
  const std::type_info &RTypeInfo(const char *name);
  //: Given a standardised name return the std::type_info instance.
  // Reverse lookup.  Given the standard name find the
  // type info for that class.
  
  void AddTypeName(const std::type_info &info,const char *newname);
  //: Set the standard name to be used for a particular type.
  
  void AddTypeName(const char *sysname,const char *newname);
  //: Set the standard name to be used for a particular type.
  
  void AddTypeHandleName(const std::type_info &info,const char *newname);
  //: Add body to handle type mapping.
  
  //:-
  
  //! userlevel=Normal
  //: Register typename.
  // Class to make it easy to register typename. Use as global
  // variables. <p>
  // e.g. for class xyzC declare the following as global
  // in a .cc file preferably in the same file as the definition of XyzC <p>
  //  static TypeNameC typeNameXyz(typeid(XyzC),"XyzC");
  
  class TypeNameC {
  public:
    TypeNameC(const std::type_info &info,const char *newname)
    { AddTypeName(info,newname); }
    //: Constructor.

    TypeNameC(const std::type_info &info,const char *newname,const std::type_info &bodyType) {
      AddTypeName(info,newname); 
      AddTypeHandleName(bodyType,newname);
    }
    //: Constructor.
  };
  
}
#endif
